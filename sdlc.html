<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Ciclo de Vida del Desarrollo de Software (SDLC) - Calidad de Software</title>
  <link rel="stylesheet" href="estilos.css">
</head>
<body>
  <header>
    <h1>Ciclo de Vida del Desarrollo de Software (SDLC)</h1>
  </header>
  
  
  <nav>
    <a href="index.html">Inicio</a>
    <a href="calidad.html">Gestión de la Calidad</a>
    <a href="sdlc.html">Procesos de Desarrollo de Software</a>
    <a href="metodologias.html">Metodologías Ágiles</a>
    <a href="recursos.html">Recursos y Aprendizaje</a>
    <a href="funcionalidades.html">Funcionalidades</a>
    <a href="adicionales.html">Secciones Adicionales</a>
  </nav>


  <section>
    <button class="accordion">Ciclo de Vida del Desarrollo de Software (SDLC)</button>
    <div class="panel">
      <div class="panel-content">
        <h2 style="color: #1E3A8A; margin-top: 10px;">¿Qué es el SDLC?</h2>
        <p>El Ciclo de Vida del Desarrollo de Software (SDLC) es el proceso estructurado que se sigue para planificar, crear, probar, implementar y mantener un sistema o aplicación de software. Su objetivo es garantizar la calidad, eficiencia y fiabilidad del producto final.</p>
        
        <h2 style="color: #1E3A8A; margin-top: 30px;">Etapas principales del SDLC</h2>
        
        <h3 style="color: #1E3A8A; margin-top: 15px;">1. Recolección y análisis de requisitos</h3>
        <p>Se identifican las necesidades del cliente o usuario final.</p>
        <p>Se definen las funciones, restricciones y objetivos del software.</p>
        <p>Se crea el documento de requerimientos del sistema (SRS), que servirá como base para el desarrollo.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">2. Diseño del sistema</h3>
        <p>Se establecen la arquitectura, componentes, interfaces y flujo de datos del software.</p>
        <p>Incluye el diseño de bases de datos, diagramas UML y la estructura del sistema.</p>
        <p>El resultado es un modelo técnico detallado que guiará la implementación.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">3. Implementación o desarrollo</h3>
        <p>Los programadores escriben el código fuente siguiendo las especificaciones del diseño.</p>
        <p>Se utilizan lenguajes de programación y herramientas adecuadas.</p>
        <p>Se construyen y prueban los módulos individuales (unidades).</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">4. Pruebas (Testing)</h3>
        <p>Se verifica que el software funcione correctamente y cumpla los requisitos definidos.</p>
        <p>Se realizan pruebas de unidad, integración, sistema y aceptación.</p>
        <p>El objetivo es detectar y corregir errores antes de la entrega.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">5. Despliegue o implementación</h3>
        <p>El software se instala y pone en funcionamiento en el entorno real del usuario.</p>
        <p>Puede realizarse en una sola entrega o de forma gradual.</p>
        <p>Se brinda capacitación y soporte inicial a los usuarios.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">6. Mantenimiento</h3>
        <p>Se realizan actualizaciones, correcciones y mejoras tras la entrega.</p>
        <p>Permite adaptar el software a nuevas necesidades o tecnologías.</p>
        <p>Es una fase continua durante la vida útil del sistema.</p>
        
        <h2 style="color: #1E3A8A; margin-top: 30px;">Importancia del SDLC</h2>
        <p>El Ciclo de Vida del Desarrollo de Software (SDLC) es fundamental porque permite que el proceso de creación de un sistema sea organizado, controlado y eficiente. Gracias a su estructura por etapas, ayuda a que los equipos de trabajo planifiquen adecuadamente cada fase del proyecto, evitando errores costosos y retrasos innecesarios. Además, garantiza que el software desarrollado cumpla con los requisitos del usuario, manteniendo altos niveles de calidad y fiabilidad.</p>
        
        <p>Otro aspecto clave es que el SDLC facilita la comunicación entre los desarrolladores, los clientes y los usuarios finales, ya que todos trabajan con una guía clara de los objetivos y avances del proyecto. También contribuye a una mejor gestión de los recursos, el tiempo y los costos, optimizando el desarrollo de principio a fin. Por último, su enfoque estructurado permite que el software sea fácil de mantener, actualizar y escalar con el tiempo, asegurando su vigencia y adaptación a nuevas necesidades o tecnologías.</p>
      </div>
    </div>
  </section>

  <section>
    <button class="accordion">Modelos Tradicionales del Desarrollo de Software</button>
    <div class="panel">
      <div class="panel-content">
        <p>Los modelos tradicionales del desarrollo de software son enfoques estructurados que describen cómo se organiza, planifica y ejecuta un proyecto de software. Su objetivo es guiar a los equipos a través de las distintas etapas del Ciclo de Vida del Desarrollo de Software (SDLC) de forma controlada y predecible.</p>
        
        <hr style="border: 2px solid #1E3A8A; margin: 30px 0;">
        
        <h2 style="color: #1E3A8A; margin-top: 20px;">Modelo en Cascada</h2>
        <p>El modelo en cascada es el enfoque más clásico y secuencial dentro del desarrollo de software. Su funcionamiento se basa en avanzar etapa por etapa, sin retroceder, lo que genera un flujo lineal de actividades. Cada fase depende de la anterior, y no comienza hasta que la anterior ha sido completamente finalizada y verificada.</p>
        <p>Las fases típicas del modelo incluyen la definición de requisitos, el diseño del sistema, la implementación del código, las pruebas, el despliegue y finalmente el mantenimiento.</p>
        
        <!-- Imagen del modelo en cascada -->
        <div style="text-align: center; margin: 20px 0;">
          <img src="img/cascada.jpg" alt="Diagrama del Modelo en Cascada" style="max-width: 80%; height: auto; border-radius: 8px;">
        </div>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Ventajas:</h3>
        <p>• Es fácil de comprender y administrar, gracias a su estructura ordenada.</p>
        <p>• Facilita una planificación detallada desde el inicio del proyecto.</p>
        <p>• Resulta útil cuando se tiene claridad total sobre los requisitos del sistema.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Desventajas:</h3>
        <p>• Es muy rígido, ya que no permite volver a fases anteriores sin reiniciar parte del proceso.</p>
        <p>• Los errores se detectan tarde, generalmente en la etapa de pruebas.</p>
        <p>• Se adapta mal a cambios en los requerimientos del cliente.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Cuándo usarlo:</h3>
        <p>Este modelo se recomienda cuando los requisitos están completamente definidos y no se esperan modificaciones durante el desarrollo. Es ideal para proyectos pequeños o con bajo nivel de riesgo, donde la estabilidad del producto es más importante que la flexibilidad.</p>
        
        <hr style="border: 2px solid #1E3A8A; margin: 30px 0;">
        
        <h2 style="color: #1E3A8A; margin-top: 20px;">Modelo en V</h2>
        <p>El modelo en V surge como una evolución del modelo en cascada, pero incorpora un mayor enfoque en la calidad y las pruebas. La forma de "V" representa la relación directa entre las fases de desarrollo (del lado izquierdo) y las fases de prueba (del lado derecho).</p>
        <p>Cada etapa del desarrollo tiene una fase de verificación correspondiente, lo que asegura que se cumplan los objetivos de calidad desde el principio. De esta manera, por ejemplo, los requisitos definidos se validan mediante pruebas de aceptación, y el diseño se comprueba mediante pruebas de integración.</p>
        
        <!-- Imagen del modelo en V -->
        <div style="text-align: center; margin: 20px 0;">
          <img src="img/v.png" alt="Diagrama del Modelo en V" style="max-width: 80%; height: auto; border-radius: 8px;">
        </div>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Ventajas:</h3>
        <p>• Promueve una verificación constante en todas las etapas.</p>
        <p>• Permite detectar errores tempranamente, reduciendo los costos de corrección.</p>
        <p>• Favorece la trazabilidad y la documentación, ya que todo el proceso queda registrado.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Desventajas:</h3>
        <p>• Su estructura sigue siendo poco flexible frente a cambios.</p>
        <p>• Requiere una planificación exhaustiva y un esfuerzo considerable en documentación.</p>
        <p>• No se adapta bien a proyectos donde los requisitos pueden evolucionar con el tiempo.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Cuándo usarlo:</h3>
        <p>El modelo en V es apropiado para proyectos en los que la confiabilidad y las pruebas son críticas, como los sistemas médicos, militares o aeroespaciales. También es útil cuando los requisitos son claros y estables desde el inicio y se busca una alta calidad y seguridad en el producto final.</p>
        
        <hr style="border: 2px solid #1E3A8A; margin: 30px 0;">
        
        <h2 style="color: #1E3A8A; margin-top: 20px;">Modelos Iterativos e Incrementales</h2>
        <p>Los modelos iterativos e incrementales combinan dos enfoques complementarios: la iteración, que implica repetir ciclos de desarrollo, y el incremento, que consiste en agregar progresivamente nuevas funciones al sistema.</p>
        <p>En lugar de construir el software completo desde el principio, el proyecto se divide en versiones o entregas parciales. Cada iteración incluye fases de análisis, diseño, codificación y prueba, generando un producto funcional que se va ampliando en las siguientes etapas. Esto permite ajustar el desarrollo según la retroalimentación del usuario, mejorando la calidad y adaptabilidad del software.</p>
        
        <!-- Imagen del modelo iterativo -->
        <div style="text-align: center; margin: 20px 0;">
          <img src="img/iterativo.jpg" alt="Diagrama del Modelo Iterativo" style="max-width: 80%; height: auto; border-radius: 8px;">
        </div>
        
        <!-- Imagen del modelo incremental -->
        <div style="text-align: center; margin: 20px 0;">
          <img src="img/incremental.jpg" alt="Diagrama del Modelo Incremental" style="max-width: 80%; height: auto; border-radius: 8px;">
        </div>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Ventajas:</h3>
        <p>• Ofrece flexibilidad ante cambios en los requisitos.</p>
        <p>• Permite entregar versiones tempranas del sistema, lo que facilita la evaluación por parte del cliente.</p>
        <p>• Favorece la detección y corrección temprana de errores.</p>
        <p>• Reduce el riesgo al dividir el desarrollo en entregas controladas.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Desventajas:</h3>
        <p>• Exige una gestión y coordinación constante del proyecto.</p>
        <p>• Puede aumentar los costos si se requieren muchas iteraciones.</p>
        <p>• La integración de los incrementos puede ser compleja.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Cuándo usarlos:</h3>
        <p>Estos modelos se recomiendan cuando los requisitos del sistema no están completamente definidos o se espera que cambien durante el desarrollo. Son ideales para proyectos grandes o de larga duración, y constituyen la base de muchas metodologías ágiles modernas, donde se busca mejorar continuamente el producto con la participación activa del usuario.</p>
      </div>
    </div>
  </section>

  <section>
    <button class="accordion">Metodologías Ágiles</button>
    <div class="panel">
      <div class="panel-content">
        <p>Las Metodologías Ágiles son enfoques modernos de desarrollo de software que buscan entregar valor al cliente de forma rápida, flexible y continua. A diferencia de los modelos tradicionales, que siguen pasos rígidos y secuenciales, las metodologías ágiles promueven un trabajo colaborativo, adaptable y centrado en las personas.</p>
        <p>Se basan en el Manifiesto Ágil (2001), el cual establece que los equipos deben priorizar la colaboración, el software funcional, la participación del cliente y la adaptabilidad frente al cambio.</p>
        
        <hr style="border: 2px solid #1E3A8A; margin: 30px 0;">
        
        <h2 style="color: #1E3A8A; margin-top: 20px;">Scrum</h2>
        <p>Scrum es la metodología ágil más difundida. Está pensada para trabajar en ciclos cortos llamados "sprints", que suelen durar entre una y cuatro semanas. En cada sprint se desarrolla un incremento funcional del producto, que se revisa, ajusta y mejora continuamente. Scrum fomenta la transparencia, la inspección constante y la adaptación.</p>
        
        <!-- Imagen de Scrum -->
        <div style="text-align: center; margin: 20px 0;">
          <img src="img/scrum.png" alt="Diagrama de Scrum" style="max-width: 80%; height: auto; border-radius: 8px;">
        </div>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Principios:</h3>
        <p>Scrum se apoya en tres pilares:</p>
        <p>• <strong>Transparencia:</strong> para que todos conozcan el estado del proyecto.</p>
        <p>• <strong>Inspección:</strong> mediante reuniones frecuentes que permiten evaluar el progreso.</p>
        <p>• <strong>Adaptación:</strong> ajustando el rumbo del trabajo cuando se detectan mejoras o errores.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Roles:</h3>
        <p>• <strong>Product Owner:</strong> es el responsable de definir qué se debe desarrollar, priorizando las tareas en función del valor que aportan al cliente.</p>
        <p>• <strong>Scrum Master:</strong> actúa como facilitador del proceso, eliminando obstáculos y asegurando que el equipo siga las reglas y valores de Scrum.</p>
        <p>• <strong>Equipo de Desarrollo:</strong> es un grupo multidisciplinario encargado de construir el producto; todos sus miembros tienen el mismo nivel de responsabilidad.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Ceremonias:</h3>
        <p>Scrum se estructura en una serie de eventos que organizan el trabajo:</p>
        <p>• <strong>Sprint Planning:</strong> es la reunión inicial donde el equipo y el Product Owner definen los objetivos y tareas del sprint.</p>
        <p>• <strong>Daily Scrum:</strong> breve reunión diaria (de unos 15 minutos) en la que el equipo comenta lo que hizo, lo que hará y los posibles impedimentos.</p>
        <p>• <strong>Sprint Review:</strong> se realiza al final del sprint para presentar el incremento del producto al cliente o partes interesadas, recibiendo su retroalimentación.</p>
        <p>• <strong>Sprint Retrospective:</strong> el equipo reflexiona sobre cómo trabajó durante el sprint y propone mejoras para el siguiente ciclo.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Artefactos:</h3>
        <p>Los artefactos son los elementos que aportan visibilidad y control al proceso:</p>
        <p>• <strong>Product Backlog:</strong> lista priorizada de todas las funcionalidades y requerimientos del producto, mantenida por el Product Owner.</p>
        <p>• <strong>Sprint Backlog:</strong> conjunto de tareas seleccionadas del Product Backlog que se desarrollarán durante el sprint.</p>
        <p>• <strong>Incremento:</strong> es la versión del producto lista para entregar o demostrar; representa el resultado tangible del sprint.</p>
        
        <hr style="border: 2px solid #1E3A8A; margin: 30px 0;">
        
        <h2 style="color: #1E3A8A; margin-top: 20px;">Kanban</h2>
        <p>Kanban es una metodología ágil basada en la visualización del flujo de trabajo y en la mejora continua del proceso. Se utiliza un tablero Kanban, dividido en columnas (por ejemplo: "Por hacer", "En progreso", "Hecho"), que permite ver de manera clara el estado de cada tarea.</p>
        <p>El objetivo principal de Kanban es maximizar la eficiencia y evitar la sobrecarga del equipo mediante la limitación del trabajo en progreso (WIP).</p>
        
        <!-- Imagen de Kanban -->
        <div style="text-align: center; margin: 20px 0;">
          <img src="img/kanban.png" alt="Tablero Kanban" style="max-width: 80%; height: auto; border-radius: 8px;">
        </div>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Principios:</h3>
        <p>• Visualizar el flujo de trabajo para identificar cuellos de botella y áreas de mejora.</p>
        <p>• Limitar el trabajo en curso (WIP) para garantizar que el equipo se concentre en completar tareas antes de comenzar nuevas.</p>
        <p>• Gestionar el flujo, buscando que el trabajo avance de forma fluida y continua.</p>
        <p>• Mejorar de forma continua, basándose en métricas reales y la colaboración del equipo.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Roles:</h3>
        <p>Kanban no establece roles definidos como Scrum. Todos los miembros del equipo comparten la responsabilidad de gestionar el tablero, actualizar el estado de las tareas y mantener el flujo de trabajo.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Ceremonias:</h3>
        <p>A diferencia de otras metodologías, Kanban no impone reuniones obligatorias, aunque se suelen realizar encuentros breves diarios para revisar el tablero y detectar bloqueos, además de reuniones periódicas de revisión del flujo para optimizar el proceso.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Artefactos:</h3>
        <p>Los artefactos de Kanban son principalmente visuales:</p>
        <p>• <strong>Tablero Kanban:</strong> herramienta central que muestra las etapas del flujo de trabajo y el estado de cada tarea.</p>
        <p>• <strong>Tarjetas Kanban:</strong> representan unidades de trabajo (tareas, historias o actividades), y se mueven de una columna a otra a medida que avanzan.</p>
        <p>• <strong>Límites WIP:</strong> restricciones en la cantidad de tareas que pueden estar en progreso simultáneamente, ayudando a evitar la sobrecarga del equipo y mejorar la productividad.</p>
        
        <hr style="border: 2px solid #1E3A8A; margin: 30px 0;">
        
        <h2 style="color: #1E3A8A; margin-top: 20px;">Extreme Programming (XP)</h2>
        <p>Extreme Programming (XP) es una metodología ágil centrada en la calidad del código y la colaboración continua entre desarrolladores y cliente. Está especialmente orientada a proyectos donde los requisitos cambian con frecuencia o se requiere un alto nivel de calidad técnica.</p>
        <p>XP propone una serie de prácticas de programación intensivas, como la integración continua, las pruebas automatizadas y la programación en pareja, para mejorar la fiabilidad y reducir errores.</p>
        
        <!-- Imagen de XP -->
        <div style="text-align: center; margin: 20px 0;">
          <img src="img/xp.jpg" alt="Diagrama de Extreme Programming" style="max-width: 80%; height: auto; border-radius: 8px;">
        </div>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Principios:</h3>
        <p>XP se apoya en valores esenciales como la comunicación, simplicidad, retroalimentación, coraje y respeto. Estos principios buscan crear un entorno de trabajo colaborativo y adaptable, donde el equipo pueda entregar software funcional de alta calidad de forma continua.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Roles:</h3>
        <p>• <strong>Cliente:</strong> define las historias de usuario, establece prioridades y aprueba las entregas.</p>
        <p>• <strong>Desarrolladores:</strong> se encargan de implementar el código, aplicar las prácticas técnicas y realizar pruebas constantes.</p>
        <p>• <strong>Coach:</strong> guía al equipo en la aplicación correcta de las prácticas de XP.</p>
        <p>• <strong>Tracker:</strong> supervisa el progreso, detectando desviaciones y asegurando que los objetivos se cumplan.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Ceremonias:</h3>
        <p>XP organiza el desarrollo en ciclos cortos e iterativos:</p>
        <p>• <strong>Planning Game:</strong> reunión donde el cliente y el equipo definen qué historias se desarrollarán y en qué orden.</p>
        <p>• <strong>Daily Stand-Up:</strong> breve encuentro diario para coordinar el trabajo y resolver bloqueos.</p>
        <p>• <strong>Iteration Planning:</strong> planificación del trabajo técnico de la iteración.</p>
        <p>• <strong>Release Planning:</strong> definición de versiones del producto que serán entregadas al cliente, normalmente cada pocas semanas.</p>
        
        <h3 style="color: #1E3A8A; margin-top: 20px;">Artefactos:</h3>
        <p>• <strong>Historias de Usuario:</strong> descripciones simples y concisas de funcionalidades desde la perspectiva del usuario final.</p>
        <p>• <strong>Código probado:</strong> todo el código se somete a pruebas unitarias y de integración para asegurar su calidad.</p>
        <p>• <strong>Pruebas automatizadas:</strong> se ejecutan continuamente para validar que los cambios no introduzcan errores.</p>
        <p>• <strong>Integración continua:</strong> cada cambio en el código se integra y prueba inmediatamente, asegurando que el sistema esté siempre en funcionamiento y la mejora continua del código.</p>
      </div>
    </div>
  </section>

  <footer>
    <p>© 2025 - Proyecto académico</p>
  </footer>

  <script>
    // Funcionalidad del acordeón principal
    var acc = document.getElementsByClassName("accordion");
    var i;

    for (i = 0; i < acc.length; i++) {
      acc[i].addEventListener("click", function() {
        // Toggle clase active
        this.classList.toggle("active");
        
        // Obtener el panel siguiente
        var panel = this.nextElementSibling;
        
        // Expandir o contraer el panel
        if (panel.style.maxHeight) {
          panel.style.maxHeight = null;
        } else {
          panel.style.maxHeight = panel.scrollHeight + "px";
        }
      });
    }

    // Funcionalidad del sub-acordeón
    var subAcc = document.getElementsByClassName("sub-accordion");
    var j;

    for (j = 0; j < subAcc.length; j++) {
      subAcc[j].addEventListener("click", function() {
        // Toggle clase active
        this.classList.toggle("active");
        
        // Obtener el sub-panel siguiente
        var subPanel = this.nextElementSibling;
        
        // Expandir o contraer el sub-panel
        if (subPanel.style.maxHeight) {
          subPanel.style.maxHeight = null;
        } else {
          subPanel.style.maxHeight = subPanel.scrollHeight + "px";
        }
        
        // Ajustar el tamaño del panel padre
        var parentPanel = this.closest('.panel');
        if (parentPanel && parentPanel.style.maxHeight) {
          parentPanel.style.maxHeight = parentPanel.scrollHeight + "px";
        }
      });
    }
  </script>
</body>
</html>
